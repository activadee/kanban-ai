name: Codex Code Review

on:
  pull_request:
    types:
      - opened
      - synchronize
      - reopened
      - ready_for_review

concurrency:
  group: codex-review-${{ github.event.pull_request.number }}
  cancel-in-progress: true

permissions:
  contents: read
  pull-requests: write
  issues: write

jobs:
  review:
    name: Run automated review
    if: github.event.pull_request.draft == false
    runs-on: ubuntu-latest
    timeout-minutes: 20

    steps:
      - name: Checkout repository
        uses: actions/checkout@v5
        with:
          fetch-depth: 0
          ref: ${{ github.event.pull_request.head.sha }}

      - name: Fetch base reference
        run: git fetch --no-tags origin ${{ github.event.pull_request.base.ref }}

      - name: Collect review inputs
        shell: bash
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail

          git diff --unified=5 origin/${{ github.event.pull_request.base.ref }}...${{ github.event.pull_request.head.sha }} > diff.txt

          gh api repos/${{ github.repository }}/issues/${{ github.event.pull_request.number }}/comments --paginate --jq '.[]' > existing_comments.jsonl
          jq -s 'map({user: .user.login, body: .body})' existing_comments.jsonl > existing_comments.json

          gh api repos/${{ github.repository }}/pulls/${{ github.event.pull_request.number }}/files --paginate --jq '.[]' > files.jsonl
          jq -s '[.[] | select(.patch != null) | {path: .filename, patch: .patch}]' files.jsonl > files.json

          cat <<EOF > review_metadata.json
          {
            "repository": "${{ github.repository }}",
            "pull_number": ${{ github.event.pull_request.number }},
            "base_ref": "${{ github.event.pull_request.base.ref }}",
            "base_sha": "${{ github.event.pull_request.base.sha }}",
            "head_sha": "${{ github.event.pull_request.head.sha }}"
          }
          EOF

      - name: Write review instructions
        run: |
          cat <<'EOF' > codex_prompt.md
          You are Codex, an automated code review assistant.
          Repository metadata is in review_metadata.json.
          The unified diff for this pull request is saved in diff.txt.
          files.json lists each changed file with its diff patch.
          existing_comments.json contains bodies of review comments that already exist; do not repeat any of them (case-insensitive comparison).

          Review the diff and identify correctness, reliability, and security issues. Prefer high-signal findings over nitpicks.

          For each finding you report:
          - Explain why it is a bug or risk.
          - Reference the specific code that changed.
          - Provide a concrete fix or mitigation strategy.
          - Limit feedback to behaviour visible in diff.txt (changed lines or their immediate context).

          Requirements:
          - Output at most 10 comments.
          - Skip any feedback already present in existing_comments.json.
          - Use files.json to calculate accurate HEAD line numbers; only comment on lines that appear on the '+' side of the diff or unchanged context lines.
          - Ignore style, formatting, or naming nits unless they cause functional issues.
          - Always set "summary" to a short string (can be empty) describing the overall review outcome.
          - If nothing actionable is found, return an empty array of comments.

          Output format (JSON only, no extra text or Markdown fencing):
          {
            "summary": "Optional one or two sentence overview",
            "comments": [
              { "path": "relative/path.ts", "line": 123, "body": "Actionable review comment" }
            ]
          }
          EOF

      - name: Run Codex review
        id: run_codex
        uses: activadee/codex-action@main
        with:
          codex-auth-json-b64: ${{ secrets.CODEX_AUTH_JSON_B64 }}
          safety-strategy: drop-sudo
          prompt-file: codex_prompt.md
          output-file: codex-output.json
          output-schema: |
            {
              "type": "object",
              "required": ["summary", "comments"],
              "additionalProperties": false,
              "properties": {
                "summary": { "type": "string" },
                "comments": {
                  "type": "array",
                  "maxItems": 10,
                  "items": {
                    "type": "object",
                    "required": ["path", "line", "body"],
                    "additionalProperties": false,
                    "properties": {
                      "path": { "type": "string", "minLength": 1 },
                      "line": { "type": "integer", "minimum": 1 },
                      "body": { "type": "string", "minLength": 1 }
                    }
                  }
                }
              }
            }

      - name: Normalize Codex review output
        shell: bash
        run: |
          node <<'NODE'
          'use strict';
          const fs = require('fs');

          const outputPath = 'codex-output.json';
          if (!fs.existsSync(outputPath)) {
            throw new Error('codex-output.json is missing');
          }

          const rawOutput = JSON.parse(fs.readFileSync(outputPath, 'utf8'));
          const files = fs.existsSync('files.json') ? JSON.parse(fs.readFileSync('files.json', 'utf8')) : [];
          const patchMap = new Map();
          for (const file of files) {
            if (file && typeof file.path === 'string' && typeof file.patch === 'string') {
              patchMap.set(file.path, file.patch);
            }
          }

          const comments = Array.isArray(rawOutput.comments) ? rawOutput.comments : [];
          const normalized = [];
          const skipped = [];

          const normalizeBody = (body) => (typeof body === 'string' ? body.trim() : '');

          const lineIsReviewable = (patch, targetLine) => {
            if (typeof patch !== 'string' || !patch.length) return false;
            const lines = patch.split('\n');
            let newLine = 0;

            for (const diffLine of lines) {
              if (diffLine.startsWith('@@')) {
                const match = /@@ -\d+(?:,\d+)? \+(\d+)(?:,(\d+))? @@/.exec(diffLine);
                if (!match) {
                  newLine = 0;
                  continue;
                }
                newLine = parseInt(match[1], 10);
                continue;
              }

              if (!diffLine.length) {
                continue;
              }

              const prefix = diffLine[0];
              if (prefix === '+' || prefix === ' ') {
                if (newLine === targetLine) {
                  return true;
                }
                newLine += 1;
              } else if (prefix === '-') {
                continue;
              }
            }

            return false;
          };

          for (const comment of comments) {
            const path = typeof comment.path === 'string' ? comment.path.trim() : '';
            const rawLine = typeof comment.line === 'number' || typeof comment.line === 'string' ? Number.parseInt(comment.line, 10) : NaN;
            const body = normalizeBody(comment.body);

            if (!path || !Number.isInteger(rawLine) || rawLine < 1 || !body) {
              skipped.push({ reason: 'invalid-shape', comment });
              continue;
            }

            if (normalized.length >= 10) {
              skipped.push({ reason: 'over-limit', path, line: rawLine, body });
              continue;
            }

            const patch = patchMap.get(path);
            if (!patch) {
              skipped.push({ reason: 'no-patch', path, line: rawLine, body });
              continue;
            }

            if (!lineIsReviewable(patch, rawLine)) {
              skipped.push({ reason: 'line-outside-diff', path, line: rawLine, body });
              continue;
            }

            if (normalized.some((existing) => existing.path === path && existing.line === rawLine && existing.body === body)) {
              skipped.push({ reason: 'duplicate', path, line: rawLine, body });
              continue;
            }

            normalized.push({ path, line: rawLine, side: 'RIGHT', body });
          }

          const summary =
            typeof rawOutput.summary === 'string' && rawOutput.summary.trim().length > 0
              ? rawOutput.summary.trim()
              : normalized.length > 0
                ? `Found ${normalized.length} potential issue${normalized.length === 1 ? '' : 's'} that should be addressed.`
                : '✅ No issues found in the current changes.';

          fs.writeFileSync('review-comments.json', JSON.stringify({ summary, comments: normalized }, null, 2));
          fs.writeFileSync('skipped-comments.json', JSON.stringify(skipped, null, 2));
          NODE

      - name: Submit review
        if: success()
        uses: actions/github-script@v7
        env:
          REVIEW_FILE: review-comments.json
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const core = require('@actions/core');

            const reviewPath = process.env.REVIEW_FILE;
            if (!reviewPath || !fs.existsSync(reviewPath)) {
              core.setFailed(`Missing review file: ${reviewPath}`);
              return;
            }

            const data = JSON.parse(fs.readFileSync(reviewPath, 'utf8'));
            const comments = Array.isArray(data.comments) ? data.comments : [];
            const summary = typeof data.summary === 'string' && data.summary.trim().length > 0
              ? data.summary.trim()
              : (comments.length
                ? `Found ${comments.length} potential issue${comments.length === 1 ? '' : 's'} that should be addressed.`
                : '✅ No issues found in the current changes.');

            const prNumber = context.payload.pull_request.number;

            if (!comments.length) {
              const existing = await github.paginate(github.rest.issues.listComments, {
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                per_page: 100
              });

              const hasNoIssuesComment = existing.some((comment) =>
                (comment.user?.login || '').includes('[bot]') &&
                /no issues found|lgtm|✅/i.test(comment.body || '')
              );

              if (!hasNoIssuesComment) {
                await github.rest.pulls.createReview({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: prNumber,
                  event: 'COMMENT',
                  body: summary
                });
              } else {
                core.info('No actionable feedback and an existing no-issues confirmation already exists; skipping review.');
              }
              return;
            }

            await github.rest.pulls.createReview({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber,
              event: 'COMMENT',
              body: summary,
              comments
            });

            core.info(`Submitted review with ${comments.length} inline comment${comments.length === 1 ? '' : 's'}.`);

      - name: Upload review artifacts
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: codex-review-debug-${{ github.run_id }}
          if-no-files-found: ignore
          retention-days: 7
          path: |
            diff.txt
            files.json
            files.jsonl
            existing_comments.json
            existing_comments.jsonl
            review_metadata.json
            codex_prompt.md
            codex-output.json
            review-comments.json
            skipped-comments.json
