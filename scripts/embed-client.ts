/**
 * Generates server/src/client-embed.ts from client/dist contents.
 *
 * Usage: bun run scripts/embed-client.ts
 */
import {promises as fs} from 'fs'
import path from 'path'

const CLIENT_DIST = path.resolve(process.cwd(), 'client', 'dist')
const OUTPUT_FILE = path.resolve(process.cwd(), 'server', 'src', 'client-embed.ts')

type RawAsset = { contentType: string; base64: string }

async function walk(dir: string, baseOut: string, out: Record<string, RawAsset>) {
    const entries = await fs.readdir(dir, {withFileTypes: true})
    for (const ent of entries) {
        const abs = path.join(dir, ent.name)
        if (ent.isDirectory()) {
            await walk(abs, baseOut + '/' + ent.name, out)
        } else if (ent.isFile()) {
            const relHttp = '/app' + (baseOut ? baseOut : '') + '/' + ent.name
            const buf = await fs.readFile(abs)
            out[relHttp.replace(/\\/g, '/')] = {
                contentType: mimeFor(ent.name),
                base64: buf.toString('base64'),
            }
        }
    }
}

function mimeFor(name: string) {
    const lower = name.toLowerCase()
    if (lower.endsWith('.html')) return 'text/html; charset=utf-8'
    if (lower.endsWith('.css')) return 'text/css; charset=utf-8'
    if (lower.endsWith('.js')) return 'text/javascript; charset=utf-8'
    if (lower.endsWith('.svg')) return 'image/svg+xml'
    if (lower.endsWith('.png')) return 'image/png'
    if (lower.endsWith('.jpg') || lower.endsWith('.jpeg')) return 'image/jpeg'
    if (lower.endsWith('.gif')) return 'image/gif'
    if (lower.endsWith('.webp')) return 'image/webp'
    if (lower.endsWith('.ico')) return 'image/x-icon'
    if (lower.endsWith('.woff2')) return 'font/woff2'
    if (lower.endsWith('.woff')) return 'font/woff'
    if (lower.endsWith('.ttf')) return 'font/ttf'
    if (lower.endsWith('.map')) return 'application/json; charset=utf-8'
    return 'application/octet-stream'
}

async function main() {
    // Sanity check
    try {
        const stat = await fs.stat(CLIENT_DIST)
        if (!stat.isDirectory()) throw new Error('not a directory')
    } catch (e) {
        console.error('[embed] client/dist not found. Run `bun run package:client` first.')
        process.exit(1)
    }

    const raw: Record<string, RawAsset> = {}
    await walk(CLIENT_DIST, '', raw)

    const ordered = Object.keys(raw).sort()
    const lines: string[] = []
    lines.push('// AUTO-GENERATED by scripts/embed-client.ts. DO NOT EDIT.')
    lines.push('export type EmbeddedAsset = { contentType: string; base64: string }')
    lines.push('const RAW: Record<string, EmbeddedAsset> = {')
    for (const key of ordered) {
        const a = raw[key]
        lines.push(`  ${JSON.stringify(key)}: { contentType: ${JSON.stringify(a?.contentType)}, base64: ${JSON.stringify(a?.base64)} },`)
    }
    lines.push('} as const')
    lines.push('const cache = new Map<string, Uint8Array>()')
    lines.push('export function getClientAsset(path: string): { bytes: Uint8Array; contentType: string } | null {')
    lines.push('  const a = (RAW as Record<string, EmbeddedAsset>)[path]')
    lines.push('  if (!a) return null')
    lines.push('  let bytes = cache.get(path)')
    lines.push('  if (!bytes) { bytes = Buffer.from(a.base64, "base64"); cache.set(path, bytes) }')
    lines.push('  return { bytes, contentType: a.contentType }')
    lines.push('}')
    lines.push('export function listClientPaths(): string[] { return Object.keys(RAW) }')

    await fs.mkdir(path.dirname(OUTPUT_FILE), {recursive: true})
    await fs.writeFile(OUTPUT_FILE, lines.join('\n'))
    console.log(`[embed] Wrote ${ordered.length} assets to ${path.relative(process.cwd(), OUTPUT_FILE)}`)
}

// eslint-disable-next-line unicorn/prefer-top-level-await
main().catch((err) => {
    console.error('[embed] failed:', err)
    process.exit(1)
})

