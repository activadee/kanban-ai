import type {AppEnv} from './env'
import type {Context} from 'hono'
import {Hono} from 'hono'

export async function registerClientRoutes(app: Hono<AppEnv>) {
  // Dynamic import of generated embed map, falls back to filesystem in dev
  // The embed is generated by scripts/embed-client.ts into server/src/client-embed.ts
  let embed: any = null
  try {
    embed = await import('./client-embed')
  } catch {
    embed = null
  }

  async function serveIndex(c: Context) {
    const path = '/app/index.html'
    // Try embed first
    const hit = embed?.getClientAsset?.(path)
    if (hit) return c.body(hit.bytes, 200, {'Content-Type': hit.contentType, 'Cache-Control': 'no-store'})
    // Fallback to filesystem for dev
    const fsPath = new URL('../../client/dist/index.html', import.meta.url).pathname
    try {
      const file = Bun.file(fsPath)
      if (await file.exists()) return new Response(file, {
        headers: {
          'Content-Type': 'text/html; charset=utf-8',
          'Cache-Control': 'no-store'
        }
      })
    } catch {
    }
    return c.text('Client not built. Run: bun run build:client', 404)
  }

  async function serveAsset(c: Context, key: string) {
    // Try embed
    const hit = embed?.getClientAsset?.(key)
    if (hit) return c.body(hit.bytes, 200, {
      'Content-Type': hit.contentType,
      'Cache-Control': cacheControlFor(hit.contentType)
    })
    // Fallback to filesystem
    const rel = key.replace(/^\/app\/?/, '')
    const fsPath = new URL(`../../client/dist/${rel}`, import.meta.url).pathname
    try {
      const file = Bun.file(fsPath)
      if (await file.exists()) return new Response(file, {
        headers: {
          'Content-Type': contentTypeFor(rel),
          'Cache-Control': cacheControlFor(contentTypeFor(rel))
        }
      })
    } catch {
    }
    return null
  }

  function contentTypeFor(name: string) {
    const lower = name.toLowerCase()
    if (lower.endsWith('.html')) return 'text/html; charset=utf-8'
    if (lower.endsWith('.css')) return 'text/css; charset=utf-8'
    if (lower.endsWith('.js')) return 'text/javascript; charset=utf-8'
    if (lower.endsWith('.svg')) return 'image/svg+xml'
    if (lower.endsWith('.png')) return 'image/png'
    if (lower.endsWith('.jpg') || lower.endsWith('.jpeg')) return 'image/jpeg'
    if (lower.endsWith('.gif')) return 'image/gif'
    if (lower.endsWith('.webp')) return 'image/webp'
    if (lower.endsWith('.ico')) return 'image/x-icon'
    if (lower.endsWith('.woff2')) return 'font/woff2'
    if (lower.endsWith('.woff')) return 'font/woff'
    if (lower.endsWith('.ttf')) return 'font/ttf'
    if (lower.endsWith('.map')) return 'application/json; charset=utf-8'
    return 'application/octet-stream'
  }

  function cacheControlFor(ct: string) {
    if (/text\/html/.test(ct)) return 'no-store'
    return 'public, max-age=31536000, immutable'
  }

  // Index at /app and /app/
  app.get('/app', serveIndex)
  app.get('/app/', serveIndex)
  // Static assets or SPA fallback
  app.get('/app/*', async (c) => {
    const urlPath = new URL(c.req.url).pathname
    const res = await serveAsset(c, urlPath)
    if (res) return res
    return serveIndex(c)
  })
}

